package MetaNotes::Models;
use strict;
use warnings;
no  warnings 'once';
use base     'Exporter';
use aliased  'MetaNotes::H';

use AnyEvent::CouchDB;
use JSON;
use Data::Dump 'pp';
use Carp;

our @EXPORT_OK   = qw($json $db %Object $User $Space $Widget $Note $Image $View &metaspace);
our %EXPORT_TAGS = (all => \@EXPORT_OK);

# What do I need from CouchDB to make this work?
# - view of all users
# - view of all spaces
# - view of anything by tag
# - view of spaces by tag
# - view of spaces by user
# - view of space and its notes
# - full-text search

our %CONFIG;
*CONFIG = *MetaNotes::CONFIG;

# JSON encoder/decoder
our $json;

# AnyEvent::CouchDB instance
our $db;

# a mixin for providing before/after method modifiers
# TODO? - Maybe I still have to write AO.
#_____________________________________________________________________________
our $Modifiable = H->new({
  before => sub {
    my ($self, $method, $before) = @_;
    my $original = $self->{$method};
    $self->{$method} = sub {
      my ($self, @args) = @_;
      $before->($self, \@args);
      $original->($self, @args);
    };
  },
  after => sub {
    my ($self, $method, $after) = @_;
    my $original = $self->{$method};
    $self->{$method} = sub {
      my ($self, @args) = @_;
      my @return = $original->($self, @args);
      $after->($self, \@args, \@return);
    };
  },
});

# a mixin for objects that are saved as CouchDB documents
#_____________________________________________________________________________
our $CouchObject = H->new({

  # return an id based on the params
  # return value may be undef for objects that want autogenerated ids
  # DERIVATIVES OF $CouchObject SHOULD OVERRIDE THIS.
  make_id => sub { $_[1] },

  # $self->_id
  id => sub { $_[0]->_id },

  # $self->_rev
  rev => sub { $_[0]->_rev },

  # when called with a hashref
  #   create the doc and return it as an object
  create => sub {
    my ($self, $doc) = @_;
    $self = $self->clone($doc) if ($doc);
    my $id = $self->{_id} = $self->make_id;
    delete $self->{_id} if not defined $self->{_id};
    my $data = $self->to_hash;
    $db->save_doc($data)->recv;
    $self->_rev($data->{_rev});
    $self;
  },

  find => sub {
    my ($self, $x) = @_;
    my $id  = $self->_id || $self->make_id($x);
    $db->open_doc($id)->recv;
  },

  read => sub {
    my ($self) = @_;
    my $id = $self->make_id;
    # FIXME - this is segfaulting for some reason.  Don't use this until it's fixed.
    $self = $db->open_doc($id)->recv;
  },

  update => sub {
    my ($self) = @_;
    confess "You can't update a document unless it has an id and a rev.  Try calling create(), first."
      unless ($self->id && $self->rev);
    my $doc = $self->to_hash;
    $db->save_doc($doc)->recv;
    $self->merge($doc);
    $self;
  },

  delete => sub {
    my ($self) = @_;
    $db->remove_doc($self)->recv;
  },

});

# View
#_____________________________________________________________________________
our $View = H->new({

  spaces_for_user => sub {
    undef;
  },

  notes_for_space => sub {
    undef;
  },

  notes_for_space_initial => sub {
    undef;
  },

  notes_for_space_not_initial => sub {
    undef;
  },

});

# User
#_____________________________________________________________________________
our $User = $CouchObject->clone({
  %$Modifiable,

  type     => 'User',
  name     => '',
  password => '',

  set_encrypted_password => sub {
    my ($self, $password) = @_;
    $self->password(crypt($password, $MetaNotes::CONFIG{salt}));
  },

  make_id  => sub {
    my ($self, $name) = @_;
    $name ||= $self->name;
    confess 'User needs a $name.' unless $name;
    my $id = "User-$name";
    # warn $id;
    $id;
  },

});

# Space
#_____________________________________________________________________________
our $Space = $CouchObject->clone({
  %$Modifiable,

  type => 'Space',
  path => '',

  make_id => sub {
    my ($self, $path) = @_;
    if (defined($path) && ($path ne '/')) {
      $path = "/$path";
    } elsif (not defined $path) {
      $path = join('/', @{$self->path});
    }
    confess 'Space needs a $path.' unless $path;
    # warn "path: $path";
    "Space-$path";
  },
});

$Space->before('delete', sub {
  my ($self, $args) = @_;
  my $notes = $View->notes_for_space($self->id);
  # TODO - turn $notes into a bunch of delete requests
  # $db->bulk_docs($notes)->recv;
});

# Widget
#_____________________________________________________________________________
our $Widget = $CouchObject->clone({
  %$Modifiable,

  widget => 1,
  type   => '',
  space  => '',
  x      => 0,
  y      => 0,
  width  => 0,
  height => 0,

  move => sub {
    my ($self, $x, $y) = @_;
    $self->x($x);
    $self->y($y);
    $self->update;
  },

  send_to_space => sub {
    my ($self, $space) = @_;
  },
});

# Note
#_____________________________________________________________________________
our $Note = $Widget->clone({
  type         => 'Note',
  title        => '',
  body         => '',
  body_as_html => '',
});

# Image
#_____________________________________________________________________________
our $Image = $Widget->clone({
  type => 'Image',
  url  => '',
});

# Objects
#_____________________________________________________________________________
our %Object = (
  User   => $User,
  Space  => $Space,
  Widget => $Widget,
  Note   => $Note,
  Image  => $Image,
);

# shortcut for creating metaspace objects
sub metaspace {
  my $user = shift;
  H->new({
    type   => 'MetaSpace',
    user   => $user,
    spaces => $View->spaces_for_user($user),
  });
}

# shortcut for applying aspects
sub aspect {
  my $module = "MetaNotes::Aspect::$_[0]";
  my $path   = "MetaNotes/Aspect/$_[0].pm";
  require $path;
  $module->init;
}

# init
sub init {
  $db   = couchdb($CONFIG{db});
  $json = JSON->new->utf8->allow_blessed->convert_blessed;
  $json->filter_json_object(sub {
    my $h = shift;
    #warn pp $h;
    if (my $type = $h->{type}) {
      #warn "interpetting js object as pl object";
      $Object{$type}->clone($h);
    } else {
      $h;
    }
  });
  $db->json_encoder($json);
  aspect 'Friends';
  aspect 'Events';
}

1;

__END__

=head1 NAME

MetaNotes::Models - the objects MetaNotes manipulates

=head1 SYNOPSIS

  use MetaNotes::Models ':all';

  my $home  = $Space->find('/');
  my $about = $Space->find('metatron/about');
  my @notes = $about->notes;
  my $beppu = $User->find('beppu');

=head1 DESCRIPTION

This is my experiment in treating Perl like JavaScript.  Instead of defining
a whole bunch of classes to represent my data model, I've defined a bunch of
cloneable, slot-based objects, instead.

=head1 API

=head2 Mixins Objects

The following objects are meant to be mixed in to other objects.

=head3 $Modifiable

$Modifiable is a MetaNotes::H object that implements before() and after() methods.
It's intended to be used as a mixin.



=head2 Model Objects

=head3 $CouchObject

$CouchObject is a MetaNotes::H object that implements methods which will allow
other objects to persist themselves to CouchDB.

=head4 $object->create(\%options)

=head4 $object->delete


=head3 $User

$User is a specialized clone of $CouchObject for representing users.

=head4 $user->set_encrypted_password($password);

=head4 $user


=head3 $Space

$Space is a specialized clone of $CouchObject for representing spaces (which are pages in MetaNotes).


=head3 $Widget

$Widget is a specialized clone of $CouchObject for defining common attributes and behaviors
for all widgets.  

=head4 $widget->move($x, $y);

=head4 $widget->send_to_space($space);


=head3 $Note

$Note is a specialized clone of $Widget for representing the classical MetaNote.

=head4 $note->title

=head4 $note->body

=head4 $note->body_as_html


=head3 $Image

$Image is a specialized clone of $Widget for representing Image widgets.

=head4 $image->url


=head3 %Object



=head2 Other Exported Symbols

=head3 $json

=head3 $db

=head3 metaspace($user_name)


=head2 Aspects



=cut
